<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Simple Chase Game</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none; /* Disable scrolling and other touch gestures */
        }
        canvas {
            background-color: #fff;
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- Game Configuration ---
        const MAX_CANVAS_WIDTH = 900;
        const MAX_CANVAS_HEIGHT = 600;
        const PLAYER_SIZE = 60; // Player is now a square
        const PLAYER_SPEED = 3.2;
        const ENEMY_SIZE = 80;
        const INITIAL_ENEMY_SPEED = 1.8;
        const ENEMY_SPEED_INCREASE_PER_SEC = 0.03;
        const DISTANCE_THRESHOLD = 120; // The distance at which the enemy image changes
        const OBSTACLE_COUNT = 3;
        const OBSTACLE_WIDTH = 60;
        const OBSTACLE_HEIGHT = 60;

        // --- Game State ---
        let player, enemy, keys, joystick, startTime, elapsedTime, isGameOver, enemyImage, isEnemyImageLoaded, playerImage, isPlayerImageLoaded, closeEnemyImage, isCloseEnemyImageLoaded, isPlayerClose, obstacles, obstacleImage, isObstacleImageLoaded;
        let lastTime = 0;

        // --- Asset Loading ---
        playerImage = new Image();
        playerImage.src = 'enemy.jpg'; // Player is now the enemy image
        playerImage.onload = () => {
            isPlayerImageLoaded = true;
        };
        playerImage.onerror = () => {
            isPlayerImageLoaded = false;
            console.error("Failed to load enemy.jpg. Using a fallback rectangle.");
        };

        enemyImage = new Image();
        enemyImage.src = 'girl.jpg'; // Enemy is now the girl image
        enemyImage.onload = () => {
            isEnemyImageLoaded = true;
        };
        enemyImage.onerror = () => {
            isEnemyImageLoaded = false;
            console.error("Failed to load girl.jpg. Using a fallback circle.");
        };

        closeEnemyImage = new Image();
        closeEnemyImage.src = 'rui.png'; // Image to show when enemy is close
        closeEnemyImage.onload = () => {
            isCloseEnemyImageLoaded = true;
        };
        closeEnemyImage.onerror = () => {
            isCloseEnemyImageLoaded = false;
            console.error("Failed to load rui.png. Using a fallback rectangle.");
        };

        obstacleImage = new Image();
        obstacleImage.src = '春巻き.jpg';
        obstacleImage.onload = () => {
            isObstacleImageLoaded = true;
        };
        obstacleImage.onerror = () => {
            isObstacleImageLoaded = false;
            console.error("Failed to load 春巻き.jpg. Using a fallback rectangle.");
        };

        // --- Game Functions ---

        function reset() {
            isGameOver = false;
            isPlayerClose = false;
            startTime = performance.now();
            elapsedTime = 0;

            const canvasRatio = canvas.width / MAX_CANVAS_WIDTH;
            
            player = {
                x: canvas.width / 4,
                y: canvas.height / 2,
                width: PLAYER_SIZE * canvasRatio,
                height: PLAYER_SIZE * canvasRatio
            };

            enemy = {
                x: canvas.width - ENEMY_SIZE * canvasRatio * 2,
                y: canvas.height / 2,
                width: ENEMY_SIZE * canvasRatio,
                height: ENEMY_SIZE * canvasRatio,
                speed: INITIAL_ENEMY_SPEED * canvasRatio
            };

            // Create multiple small obstacles
            obstacles = [];
            const obstacleW = OBSTACLE_WIDTH * canvasRatio;
            const obstacleH = OBSTACLE_HEIGHT * canvasRatio;
            for (let i = 0; i < OBSTACLE_COUNT; i++) {
                // Avoid placing obstacles too close to player/enemy start positions
                let obsX, obsY;
                do {
                    obsX = Math.random() * (canvas.width - obstacleW);
                    obsY = Math.random() * (canvas.height - obstacleH);
                } while (
                    (obsX < player.x + player.width * 2 && obsX + obstacleW > player.x - player.width) ||
                    (obsX < enemy.x + enemy.width * 2 && obsX + obstacleW > enemy.x - enemy.width)
                );

                obstacles.push({
                    x: obsX,
                    y: obsY,
                    width: obstacleW,
                    height: obstacleH
                });
            }

            keys = {
                ArrowUp: false, W: false,
                ArrowDown: false, S: false,
                ArrowLeft: false, A: false,
                ArrowRight: false, D: false
            };

            joystick = {
                active: false,
                baseX: 0, baseY: 0,
                stickX: 0, stickY: 0,
                dx: 0, dy: 0
            };
        }

        function handleResize() {
            const oldWidth = canvas.width;
            const oldHeight = canvas.height;

            const scale = Math.min(
                window.innerWidth / MAX_CANVAS_WIDTH,
                window.innerHeight / MAX_CANVAS_HEIGHT,
                1
            );
            const newWidth = MAX_CANVAS_WIDTH * scale;
            const newHeight = MAX_CANVAS_HEIGHT * scale;

            if (oldWidth > 0 && oldHeight > 0) {
                const ratioX = newWidth / oldWidth;
                const ratioY = newHeight / oldHeight;
                if (player) {
                    player.x *= ratioX;
                    player.y *= ratioY;
                }
                if (enemy) {
                    enemy.x *= ratioX;
                    enemy.y *= ratioY;
                }
                if (obstacles) {
                    obstacles.forEach(obstacle => {
                        obstacle.x *= ratioX;
                        obstacle.y *= ratioY;
                    });
                }
            }

            canvas.width = newWidth;
            canvas.height = newHeight;
            
            // Re-calculate sizes based on new canvas dimensions
            const canvasRatio = canvas.width / MAX_CANVAS_WIDTH;
            if(player) {
                player.width = PLAYER_SIZE * canvasRatio;
                player.height = PLAYER_SIZE * canvasRatio;
            }
            if(enemy) {
                enemy.width = ENEMY_SIZE * canvasRatio;
                enemy.height = ENEMY_SIZE * canvasRatio;
                enemy.speed = (INITIAL_ENEMY_SPEED + (elapsedTime / 1000) * ENEMY_SPEED_INCREASE_PER_SEC) * canvasRatio;
            }
            if(obstacles) {
                obstacles.forEach(obstacle => {
                    obstacle.width = OBSTACLE_WIDTH * canvasRatio;
                    obstacle.height = OBSTACLE_HEIGHT * canvasRatio;
                });
            }

            render(); // Re-render immediately after resize
        }

        function update(deltaTime) {
            if (isGameOver) return;

            elapsedTime = performance.now() - startTime;
            const canvasRatio = canvas.width / MAX_CANVAS_WIDTH;

            // --- Player Movement ---
            let moveX = 0;
            let moveY = 0;

            if (joystick.active) {
                moveX = joystick.dx;
                moveY = joystick.dy;
            } else {
                if (keys.ArrowUp || keys.W) moveY -= 1;
                if (keys.ArrowDown || keys.S) moveY += 1;
                if (keys.ArrowLeft || keys.A) moveX -= 1;
                if (keys.ArrowRight || keys.D) moveX += 1;
            }

            const magnitude = Math.sqrt(moveX * moveX + moveY * moveY);
            if (magnitude > 0) {
                const normalizedDx = moveX / magnitude;
                const normalizedDy = moveY / magnitude;
                let nextX = player.x + normalizedDx * PLAYER_SPEED * canvasRatio;
                let nextY = player.y + normalizedDy * PLAYER_SPEED * canvasRatio;

                // Obstacle collision detection
                let collision = false;
                for (const obstacle of obstacles) {
                    if (
                        nextX < obstacle.x + obstacle.width &&
                        nextX + player.width > obstacle.x &&
                        nextY < obstacle.y + obstacle.height &&
                        nextY + player.height > obstacle.y
                    ) {
                        collision = true;
                        break;
                    }
                }

                if (!collision) {
                    player.x = nextX;
                    player.y = nextY;
                }
            }

            // Player bounds collision
            player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
            player.y = Math.max(0, Math.min(canvas.height - player.height, player.y));

            // --- Enemy Movement ---
            const dx = (player.x + player.width / 2) - (enemy.x + enemy.width / 2);
            const dy = (player.y + player.height / 2) - (enemy.y + enemy.height / 2);
            const enemyMagnitude = Math.sqrt(dx * dx + dy * dy);

            // Check if the player is close to the enemy
            const threshold = DISTANCE_THRESHOLD * canvasRatio;
            isPlayerClose = enemyMagnitude < threshold;
            
            enemy.speed = (INITIAL_ENEMY_SPEED + (elapsedTime / 1000) * ENEMY_SPEED_INCREASE_PER_SEC) * canvasRatio;

            if (enemyMagnitude > 0) {
                enemy.x += (dx / enemyMagnitude) * enemy.speed;
                enemy.y += (dy / enemyMagnitude) * enemy.speed;
            }

            // --- Player-Enemy Collision Detection ---
            if (
                player.x < enemy.x + enemy.width &&
                player.x + player.width > enemy.x &&
                player.y < enemy.y + enemy.height &&
                player.y + player.height > enemy.y
            ) {
                isGameOver = true;
            }
        }

        function render() {
            if (!player || !enemy) return; // Prevent rendering if state is not initialized

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw Obstacles
            if (isObstacleImageLoaded) {
                obstacles.forEach(obstacle => {
                    ctx.drawImage(obstacleImage, obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                });
            } else {
                ctx.fillStyle = 'green';
                obstacles.forEach(obstacle => {
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                });
            }

            // Draw Player
            if (isPlayerImageLoaded) {
                ctx.drawImage(playerImage, player.x, player.y, player.width, player.height);
            } else {
                ctx.fillStyle = 'blue';
                ctx.fillRect(player.x, player.y, player.width, player.height);
            }

            // Draw Enemy
            if (isPlayerClose && isCloseEnemyImageLoaded) {
                ctx.drawImage(closeEnemyImage, enemy.x, enemy.y, enemy.width, enemy.height);
            } else if (isEnemyImageLoaded) {
                ctx.drawImage(enemyImage, enemy.x, enemy.y, enemy.width, enemy.height);
            } else {
                ctx.fillStyle = '#808080'; // Gray fallback
                ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
            }
            
            // Draw Joystick
            if (joystick.active) {
                ctx.globalAlpha = 0.5;
                // Base
                ctx.fillStyle = 'grey';
                ctx.beginPath();
                ctx.arc(joystick.baseX, joystick.baseY, 60, 0, Math.PI * 2);
                ctx.fill();
                // Stick
                ctx.fillStyle = 'darkgrey';
                ctx.beginPath();
                ctx.arc(joystick.stickX, joystick.stickY, 30, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }

            // Draw UI
            ctx.fillStyle = 'black';
            ctx.font = `${Math.max(16, 24 * (canvas.width / MAX_CANVAS_WIDTH))}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText((elapsedTime / 1000).toFixed(2), canvas.width / 2, 10);

            if (isGameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = 'white';
                const fontSize1 = Math.max(24, 48 * (canvas.width / MAX_CANVAS_WIDTH));
                const fontSize2 = Math.max(14, 20 * (canvas.width / MAX_CANVAS_WIDTH));
                
                ctx.font = `bold ${fontSize1}px sans-serif`;
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - fontSize1);
                
                ctx.font = `${fontSize2}px sans-serif`;
                ctx.fillText('Press R to Retry or Tap', canvas.width / 2, canvas.height / 2 + 10);
            }
        }

        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            update(deltaTime);
            render();

            requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---
        window.addEventListener('resize', handleResize);
        
        document.addEventListener('keydown', (e) => {
            if (e.key.toUpperCase() === 'R' && isGameOver) {
                reset();
            }
            // Use e.key directly for Arrow keys, and uppercase for wasd
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = true;
            } else if (keys.hasOwnProperty(e.key.toUpperCase())) {
                keys[e.key.toUpperCase()] = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = false;
            } else if (keys.hasOwnProperty(e.key.toUpperCase())) {
                keys[e.key.toUpperCase()] = false;
            }
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (isGameOver) {
                reset();
                return;
            }
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;

            // Activate joystick if touch is in the bottom-left quadrant
            if (touchX < canvas.width / 2 && touchY > canvas.height / 2) {
                joystick.active = true;
                joystick.baseX = touchX;
                joystick.baseY = touchY;
                joystick.stickX = touchX;
                joystick.stickY = touchY;
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!joystick.active) return;

            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            joystick.stickX = touch.clientX - rect.left;
            joystick.stickY = touch.clientY - rect.top;

            let dx = joystick.stickX - joystick.baseX;
            let dy = joystick.stickY - joystick.baseY;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 60) { // Clamp stick movement
                dx = (dx / dist) * 60;
                dy = (dy / dist) * 60;
                joystick.stickX = joystick.baseX + dx;
                joystick.stickY = joystick.baseY + dy;
            }
            
            joystick.dx = dx;
            joystick.dy = dy;

        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            if (joystick.active) {
                joystick.active = false;
                joystick.dx = 0;
                joystick.dy = 0;
            }
        });
        
        canvas.addEventListener('click', (e) => {
            if (isGameOver) {
                reset();
            }
        });


        // --- Initialization ---
        handleResize();
        reset();
        requestAnimationFrame(gameLoop);

    </script>
</body>
</html>
